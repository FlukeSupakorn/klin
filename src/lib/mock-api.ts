// Mock API for file organization and summarization

export interface OrganizeRequest {
  action: 'organize' | 'Borganize' | 'summary' | 'Bsummary'
  file_paths: string[]
  auto_move?: boolean
  auto_rename?: boolean
}

export interface FileOrganizeResult {
  move?: string
  rename?: string
  summary?: string
}

export interface OrganizeResponse {
  result: Record<string, FileOrganizeResult>
}

// New interface for queue-based organization
export interface OrganizeFileResponse {
  file_path: string
  original_name: string
  original_folder: string
  suggested_name: string
  suggested_folder: string
  status: 'pending' | 'processing' | 'completed' | 'approved' | 'rejected'
  auto_move_applied?: boolean
  auto_rename_applied?: boolean
}

// Helper function to get file extension
const getFileExtension = (filename: string): string => {
  const parts = filename.split('.')
  return parts.length > 1 ? parts[parts.length - 1].toLowerCase() : ''
}

// Helper function to get file type category
const getFileCategory = (filename: string): string => {
  const ext = getFileExtension(filename)
  
  if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp'].includes(ext)) return 'Images'
  if (['mp4', 'avi', 'mov', 'wmv', 'flv', 'mkv'].includes(ext)) return 'Videos'
  if (['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx'].includes(ext)) return 'Documents'
  if (['js', 'ts', 'tsx', 'jsx', 'py', 'java', 'cpp', 'c', 'html', 'css', 'rs'].includes(ext)) return 'Code'
  if (['zip', 'rar', '7z', 'tar', 'gz'].includes(ext)) return 'Archives'
  if (['txt', 'md', 'log'].includes(ext)) return 'Text'
  
  return 'Others'
}

// Mock API delay
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))

// Mock organize single file
export const organizeFile = async (filePath: string): Promise<OrganizeResponse> => {
  await delay(800) // Simulate API delay
  
  const filename = filePath.split(/[\/\\]/).pop() || ''
  const nameWithoutExt = filename.replace(/\.[^/.]+$/, '')
  const ext = getFileExtension(filename)
  const category = getFileCategory(filename)
  
  const pathParts = filePath.split(/[\/\\]/)
  pathParts.pop()
  const parentPath = pathParts.join('/')
  
  return {
    result: {
      [filename]: {
        move: `${parentPath}/${category}/mock`,
        rename: ext ? `${nameWithoutExt}-mock.${ext}` : `${nameWithoutExt}-mock`,
        summary: `# ${filename}\n\nThis is a mock summary for the file.\n\n## Details\n- **Type**: ${category}\n- **Original Name**: ${filename}\n- **New Location**: ${category}/mock\n- **Status**: Ready to organize`
      }
    }
  }
}

// Mock organize batch files
export const organizeBatchFiles = async (filePaths: string[]): Promise<OrganizeResponse> => {
  await delay(1200) // Simulate API delay
  
  const result: Record<string, FileOrganizeResult> = {}
  
  filePaths.forEach(filePath => {
    const filename = filePath.split(/[\/\\]/).pop() || ''
    const nameWithoutExt = filename.replace(/\.[^/.]+$/, '')
    const ext = getFileExtension(filename)
    const category = getFileCategory(filename)
    
    const pathParts = filePath.split(/[\/\\]/)
    pathParts.pop()
    const parentPath = pathParts.join('/')
    
    result[filename] = {
      move: `${parentPath}/${category}/mock`,
      rename: ext ? `${nameWithoutExt}-mock.${ext}` : `${nameWithoutExt}-mock`,
      summary: `# ${filename}\n\nThis is a mock summary for the file.\n\n## Details\n- **Type**: ${category}\n- **Original Name**: ${filename}\n- **New Location**: ${category}/mock\n- **Status**: Ready to organize`
    }
  })
  
  return { result }
}

// Mock summarize single file
export const summarizeFile = async (filePath: string): Promise<OrganizeResponse> => {
  await delay(1000) // Simulate API delay
  
  const filename = filePath.split(/[\/\\]/).pop() || ''
  const category = getFileCategory(filename)
  const ext = getFileExtension(filename)
  
  const summary = `# File Summary: ${filename}

## Overview
This is a mock AI-generated summary for **${filename}**.

## File Information
- **Type**: ${category}
- **Extension**: ${ext || 'none'}
- **Category**: ${category}

## Content Analysis
This file appears to be a ${category.toLowerCase()} file. In a real implementation, this would contain:
- Detailed content analysis
- Key points and highlights
- Metadata information
- Recommendations

## Suggested Actions
1. Organize into ${category} folder
2. Add descriptive tags
3. Create backup if important

---
*Generated by KLIN AI Assistant*`

  return {
    result: {
      [filename]: {
        summary
      }
    }
  }
}

// Mock summarize batch files
export const summarizeBatchFiles = async (filePaths: string[]): Promise<OrganizeResponse> => {
  await delay(1500) // Simulate API delay
  
  const result: Record<string, FileOrganizeResult> = {}
  
  filePaths.forEach(filePath => {
    const filename = filePath.split(/[\/\\]/).pop() || ''
    const category = getFileCategory(filename)
    const ext = getFileExtension(filename)
    
    const summary = `# File Summary: ${filename}

## Overview
This is a mock AI-generated summary for **${filename}**.

## File Information
- **Type**: ${category}
- **Extension**: ${ext || 'none'}

## Quick Summary
This ${category.toLowerCase()} file contains important content that has been analyzed by AI.

---
*Generated by KLIN AI Assistant*`

    result[filename] = { summary }
  })
  
  return { result }
}

// Main API handler
export const callOrganizeAPI = async (request: OrganizeRequest): Promise<OrganizeResponse> => {
  const { action, file_paths } = request
  
  switch (action) {
    case 'organize':
      if (file_paths.length !== 1) {
        throw new Error('organize action requires exactly one file path')
      }
      return organizeFile(file_paths[0])
    
    case 'Borganize':
      if (file_paths.length === 0) {
        throw new Error('Borganize action requires at least one file path')
      }
      return organizeBatchFiles(file_paths)
    
    case 'summary':
      if (file_paths.length !== 1) {
        throw new Error('summary action requires exactly one file path')
      }
      return summarizeFile(file_paths[0])
    
    case 'Bsummary':
      if (file_paths.length === 0) {
        throw new Error('Bsummary action requires at least one file path')
      }
      return summarizeBatchFiles(file_paths)
    
    default:
      throw new Error(`Unknown action: ${action}`)
  }
}

// ==================== New Queue-Based Organization API ====================

// Simulate AI processing delay (2-5 seconds per file)
const getRandomDelay = () => Math.floor(Math.random() * 3000) + 2000

// Mock destination folders
const mockDestinations = [
  'Documents',
  'Images',
  'Videos',
  'Music',
  'Archives',
  'Applications',
  'Code',
  'Others',
]

// Get a random destination folder based on file type
const getSuggestedDestination = (filename: string): string => {
  const category = getFileCategory(filename)
  return category
}

// Generate a suggested name based on file type
const generateSuggestedName = (originalName: string): string => {
  const ext = getFileExtension(originalName)
  const nameWithoutExt = originalName.replace(/\.[^/.]+$/, '')
  
  // Mock AI-generated descriptive names
  const descriptiveNames = [
    'Project_Report',
    'Meeting_Notes',
    'Vacation_Photo',
    'Screenshot_Capture',
    'Document_Scan',
    'Invoice_Payment',
    'Receipt_Purchase',
    'Presentation_Slides',
    'Data_Analysis',
    'Code_Review',
  ]
  
  const randomName = descriptiveNames[Math.floor(Math.random() * descriptiveNames.length)]
  const timestamp = new Date().toISOString().split('T')[0]
  
  return ext ? `${randomName}_${timestamp}.${ext}` : `${randomName}_${timestamp}`
}

// Process a single file with AI simulation
export const processFileOrganization = async (
  filePath: string,
  autoMove: boolean,
  autoRename: boolean
): Promise<OrganizeFileResponse> => {
  // Simulate processing delay
  await delay(getRandomDelay())

  const fileName = filePath.split('\\').pop() || filePath.split('/').pop() || filePath
  const folderPath = filePath.substring(0, filePath.lastIndexOf('\\') || filePath.lastIndexOf('/'))

  return {
    file_path: filePath,
    original_name: fileName,
    original_folder: folderPath,
    suggested_name: generateSuggestedName(fileName),
    suggested_folder: getSuggestedDestination(fileName),
    status: 'completed',
    auto_move_applied: autoMove,
    auto_rename_applied: autoRename,
  }
}

// Process multiple files with queue and progress tracking
export const organizeFilesQueue = async (
  filePaths: string[],
  autoMove: boolean,
  autoRename: boolean,
  onProgress?: (response: OrganizeFileResponse, current: number, total: number) => void,
  checkCancelled?: () => boolean
): Promise<OrganizeFileResponse[]> => {
  const results: OrganizeFileResponse[] = []

  for (let i = 0; i < filePaths.length; i++) {
    // Check if cancelled before processing next file
    if (checkCancelled && checkCancelled()) {
      console.log('Organization cancelled by user')
      break
    }

    // Set status to processing before starting
    const processingUpdate: OrganizeFileResponse = {
      file_path: filePaths[i],
      original_name: filePaths[i].split('\\').pop() || filePaths[i].split('/').pop() || filePaths[i],
      original_folder: '',
      suggested_name: '',
      suggested_folder: '',
      status: 'processing',
    }

    if (onProgress) {
      onProgress(processingUpdate, i, filePaths.length)
    }

    // Process the file
    const response = await processFileOrganization(filePaths[i], autoMove, autoRename)

    results.push(response)

    // Call progress callback with completed result
    if (onProgress) {
      onProgress(response, i + 1, filePaths.length)
    }
  }

  return results
}
