// Mock API for file organization and summarization

export interface OrganizeRequest {
  action: 'organize' | 'Borganize' | 'summary' | 'Bsummary'
  file_paths: string[]
}

export interface FileOrganizeResult {
  move?: string
  rename?: string
  summary?: string
}

export interface OrganizeResponse {
  result: Record<string, FileOrganizeResult>
}

// Helper function to get file extension
const getFileExtension = (filename: string): string => {
  const parts = filename.split('.')
  return parts.length > 1 ? parts[parts.length - 1].toLowerCase() : ''
}

// Helper function to get file type category
const getFileCategory = (filename: string): string => {
  const ext = getFileExtension(filename)
  
  if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp'].includes(ext)) return 'Images'
  if (['mp4', 'avi', 'mov', 'wmv', 'flv', 'mkv'].includes(ext)) return 'Videos'
  if (['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx'].includes(ext)) return 'Documents'
  if (['js', 'ts', 'tsx', 'jsx', 'py', 'java', 'cpp', 'c', 'html', 'css', 'rs'].includes(ext)) return 'Code'
  if (['zip', 'rar', '7z', 'tar', 'gz'].includes(ext)) return 'Archives'
  if (['txt', 'md', 'log'].includes(ext)) return 'Text'
  
  return 'Others'
}

// Mock API delay
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))

// Mock organize single file
export const organizeFile = async (filePath: string): Promise<OrganizeResponse> => {
  await delay(800) // Simulate API delay
  
  const filename = filePath.split(/[\/\\]/).pop() || ''
  const nameWithoutExt = filename.replace(/\.[^/.]+$/, '')
  const ext = getFileExtension(filename)
  const category = getFileCategory(filename)
  
  const pathParts = filePath.split(/[\/\\]/)
  pathParts.pop()
  const parentPath = pathParts.join('/')
  
  return {
    result: {
      [filename]: {
        move: `${parentPath}/${category}/mock`,
        rename: ext ? `${nameWithoutExt}-mock.${ext}` : `${nameWithoutExt}-mock`,
        summary: `# ${filename}\n\nThis is a mock summary for the file.\n\n## Details\n- **Type**: ${category}\n- **Original Name**: ${filename}\n- **New Location**: ${category}/mock\n- **Status**: Ready to organize`
      }
    }
  }
}

// Mock organize batch files
export const organizeBatchFiles = async (filePaths: string[]): Promise<OrganizeResponse> => {
  await delay(1200) // Simulate API delay
  
  const result: Record<string, FileOrganizeResult> = {}
  
  filePaths.forEach(filePath => {
    const filename = filePath.split(/[\/\\]/).pop() || ''
    const nameWithoutExt = filename.replace(/\.[^/.]+$/, '')
    const ext = getFileExtension(filename)
    const category = getFileCategory(filename)
    
    const pathParts = filePath.split(/[\/\\]/)
    pathParts.pop()
    const parentPath = pathParts.join('/')
    
    result[filename] = {
      move: `${parentPath}/${category}/mock`,
      rename: ext ? `${nameWithoutExt}-mock.${ext}` : `${nameWithoutExt}-mock`,
      summary: `# ${filename}\n\nThis is a mock summary for the file.\n\n## Details\n- **Type**: ${category}\n- **Original Name**: ${filename}\n- **New Location**: ${category}/mock\n- **Status**: Ready to organize`
    }
  })
  
  return { result }
}

// Mock summarize single file
export const summarizeFile = async (filePath: string): Promise<OrganizeResponse> => {
  await delay(1000) // Simulate API delay
  
  const filename = filePath.split(/[\/\\]/).pop() || ''
  const category = getFileCategory(filename)
  const ext = getFileExtension(filename)
  
  const summary = `# File Summary: ${filename}

## Overview
This is a mock AI-generated summary for **${filename}**.

## File Information
- **Type**: ${category}
- **Extension**: ${ext || 'none'}
- **Category**: ${category}

## Content Analysis
This file appears to be a ${category.toLowerCase()} file. In a real implementation, this would contain:
- Detailed content analysis
- Key points and highlights
- Metadata information
- Recommendations

## Suggested Actions
1. Organize into ${category} folder
2. Add descriptive tags
3. Create backup if important

---
*Generated by KLIN AI Assistant*`

  return {
    result: {
      [filename]: {
        summary
      }
    }
  }
}

// Mock summarize batch files
export const summarizeBatchFiles = async (filePaths: string[]): Promise<OrganizeResponse> => {
  await delay(1500) // Simulate API delay
  
  const result: Record<string, FileOrganizeResult> = {}
  
  filePaths.forEach(filePath => {
    const filename = filePath.split(/[\/\\]/).pop() || ''
    const category = getFileCategory(filename)
    const ext = getFileExtension(filename)
    
    const summary = `# File Summary: ${filename}

## Overview
This is a mock AI-generated summary for **${filename}**.

## File Information
- **Type**: ${category}
- **Extension**: ${ext || 'none'}

## Quick Summary
This ${category.toLowerCase()} file contains important content that has been analyzed by AI.

---
*Generated by KLIN AI Assistant*`

    result[filename] = { summary }
  })
  
  return { result }
}

// Main API handler
export const callOrganizeAPI = async (request: OrganizeRequest): Promise<OrganizeResponse> => {
  const { action, file_paths } = request
  
  switch (action) {
    case 'organize':
      if (file_paths.length !== 1) {
        throw new Error('organize action requires exactly one file path')
      }
      return organizeFile(file_paths[0])
    
    case 'Borganize':
      if (file_paths.length === 0) {
        throw new Error('Borganize action requires at least one file path')
      }
      return organizeBatchFiles(file_paths)
    
    case 'summary':
      if (file_paths.length !== 1) {
        throw new Error('summary action requires exactly one file path')
      }
      return summarizeFile(file_paths[0])
    
    case 'Bsummary':
      if (file_paths.length === 0) {
        throw new Error('Bsummary action requires at least one file path')
      }
      return summarizeBatchFiles(file_paths)
    
    default:
      throw new Error(`Unknown action: ${action}`)
  }
}
